<!DOCTYPE html>
<html>
<head>
    <title>VideoConf - Teste Super Simples</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 15px rgba(0,0,0,0.1);
        }
        
        .warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        .success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        .error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #333;
        }
        
        input[type="text"] {
            width: 250px;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }
        
        input[type="text"]:focus {
            border-color: #007bff;
            outline: none;
        }
        
        button {
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        
        .btn-primary {
            background: #007bff;
            color: white;
        }
        
        .btn-primary:hover {
            background: #0056b3;
        }
        
        .btn-success {
            background: #28a745;
            color: white;
        }
        
        .btn-warning {
            background: #ffc107;
            color: black;
        }
        
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        
        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        
        .checkbox-group {
            display: flex;
            gap: 30px;
            margin: 15px 0;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .videos {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        
        .video-box {
            border: 3px solid #ddd;
            border-radius: 10px;
            overflow: hidden;
            background: #000;
        }
        
        .video-box.local {
            border-color: #007bff;
        }
        
        .video-box.remote {
            border-color: #28a745;
        }
        
        video {
            width: 100%;
            height: 200px;
            object-fit: cover;
        }
        
        .video-label {
            background: #333;
            color: white;
            text-align: center;
            padding: 8px;
            font-weight: bold;
            position: relative;
        }
        
        .audio-indicator {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #dc3545;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: none;
        }
        
        .audio-indicator.active {
            background: #28a745;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { transform: translateY(-50%) scale(1); opacity: 1; }
            50% { transform: translateY(-50%) scale(1.2); opacity: 0.7; }
            100% { transform: translateY(-50%) scale(1); opacity: 1; }
        }
        
        .no-video {
            width: 100%;
            height: 200px;
            background: linear-gradient(45deg, #333, #555);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
        }
        
        .avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #007bff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .logs {
            height: 200px;
            overflow-y: auto;
            background: #f8f9fa;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            margin-top: 30px;
        }
        
        .status-bar {
            background: #e9ecef;
            padding: 10px 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            font-weight: bold;
        }
        
        .status-connected {
            background: #d4edda;
            color: #155724;
        }
        
        .diagnostic-section {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
            border-left: 4px solid #2196f3;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé• VideoConf - Teste de Problemas</h1>
        
        <div class="warning">
            <strong>‚ö†Ô∏è Problemas com c√¢mera/microfone?</strong><br>
            1. Clique no bot√£o "üîç Diagnosticar" antes de conectar<br>
            2. Se der erro, desmarque "Usar C√¢mera" e "Usar Microfone"<br>
            3. Voc√™ ainda poder√° ver/ouvir outros usu√°rios!
        </div>
        
        <!-- Status -->
        <div id="statusBar" class="status-bar">
            üî¥ Desconectado - Preencha os dados e teste
        </div>
        
        <!-- Diagn√≥stico -->
        <div class="diagnostic-section">
            <h3>üîç Diagn√≥stico de M√≠dia</h3>
            <button id="diagnosticBtn" class="btn-warning">üîç Testar C√¢mera/Microfone</button>
            <button id="listDevicesBtn" class="btn-warning">üì± Listar Dispositivos</button>
            <div id="diagnosticResult"></div>
        </div>
        
        <!-- Formul√°rio -->
        <div class="form-group">
            <label>Seu Nome:</label>
            <input type="text" id="nameInput" placeholder="Digite seu nome" value="Usuario_Teste">
        </div>
        
        <div class="form-group">
            <label>ID da Sala:</label>
            <input type="text" id="roomInput" placeholder="Digite o ID da sala" value="sala123">
        </div>
        
        <div class="form-group">
            <label>Op√ß√µes de M√≠dia:</label>
            <div class="checkbox-group">
                <div class="checkbox-item">
                    <input type="checkbox" id="enableVideo" checked>
                    <label for="enableVideo">üìπ Usar C√¢mera</label>
                </div>
                <div class="checkbox-item">
                    <input type="checkbox" id="enableAudio" checked>
                    <label for="enableAudio">üé§ Usar Microfone</label>
                </div>
            </div>
        </div>
        
        <!-- Bot√µes principais -->
        <div class="form-group">
            <button id="connectBtn" class="btn-primary">üöÄ Conectar na Sala</button>
            <button id="connectNoMediaBtn" class="btn-success">üëÅÔ∏è Entrar S√≥ para Ver/Ouvir</button>
            <button id="disconnectBtn" class="btn-danger" disabled>‚ùå Sair</button>
        </div>
        
        <!-- Controles durante chamada -->
        <div class="form-group">
            <button id="toggleCameraBtn" class="btn-warning" disabled>üìπ Camera ON/OFF</button>
            <button id="toggleMicBtn" class="btn-warning" disabled>üé§ Mic ON/OFF</button>
            <button id="testAudioBtn" class="btn-warning">üîä Testar Meu √Åudio</button>
            <button id="checkMicLevelBtn" class="btn-warning">üìä Ver N√≠vel do Mic</button>
            <button id="reconnectPeersBtn" class="btn-danger" disabled>üîÑ Reconectar P2P</button>
        </div>
        
        <!-- V√≠deos -->
        <div class="videos" id="videosContainer">
            <!-- V√≠deos aparecer√£o aqui -->
        </div>
        
        <!-- Logs -->
        <h3>üìù Logs do Sistema</h3>
        <div class="logs" id="logsContainer">
            Logs aparecer√£o aqui...<br>
        </div>
    </div>

    <script>
        class SimpleVideoConf {
            constructor() {
                this.ws = null;
                this.localStream = null;
                this.peerConnections = new Map();
                this.isConnected = false;
                this.userId = null;
                this.userName = null;
                
                this.setupEventListeners();
                this.log('üöÄ Sistema inicializado');
                this.log('üí° DICA: Teste o diagn√≥stico antes de conectar!');
            }
            
            setupEventListeners() {
                document.getElementById('connectBtn').onclick = () => this.connect(true);
                document.getElementById('connectNoMediaBtn').onclick = () => this.connect(false);
                document.getElementById('disconnectBtn').onclick = () => this.disconnect();
                document.getElementById('toggleCameraBtn').onclick = () => this.toggleCamera();
                document.getElementById('toggleMicBtn').onclick = () => this.toggleMic();
                document.getElementById('diagnosticBtn').onclick = () => this.runDiagnostic();
                document.getElementById('listDevicesBtn').onclick = () => this.listDevices();
                document.getElementById('testAudioBtn').onclick = () => this.testMyAudio();
                document.getElementById('checkMicLevelBtn').onclick = () => this.checkMicrophoneLevel();
                document.getElementById('reconnectPeersBtn').onclick = () => this.reconnectAllPeers();
            }
            
            async reconnectAllPeers() {
                this.log('üîÑ RECONECTANDO TODAS AS CONEX√ïES P2P...');
                
                // Fechar todas as conex√µes existentes
                this.peerConnections.forEach((pc, userId) => {
                    pc.close();
                    this.log(`üîå Fechando conex√£o antiga com ${userId}`);
                });
                this.peerConnections.clear();
                
                // Reconectar com todos os usu√°rios vis√≠veis
                const videoBoxes = document.querySelectorAll('.video-box');
                for (const box of videoBoxes) {
                    const userId = box.id.replace('video-', '');
                    if (userId !== 'local') {
                        const label = box.querySelector('.video-label');
                        const userName = label ? label.textContent.replace('üîá', '').replace('üîä', '').trim() : userId;
                        
                        this.log(`üîÅ Reconectando com ${userName}...`);
                        await this.createPeerConnection(userId, userName, true);
                    }
                }
                
                this.log('‚úÖ Processo de reconex√£o iniciado!');
                alert('üîÑ Reconex√£o P2P iniciada!\n\nAguarde alguns segundos e teste o √°udio novamente.');
            }
            
            async checkMicrophoneLevel() {
                this.log('üìä Verificando n√≠vel do microfone...');
                
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const analyser = audioContext.createAnalyser();
                    const microphone = audioContext.createMediaStreamSource(stream);
                    const dataArray = new Uint8Array(analyser.frequencyBinCount);
                    
                    analyser.smoothingTimeConstant = 0.8;
                    analyser.fftSize = 256;
                    microphone.connect(analyser);
                    
                    let maxLevel = 0;
                    const duration = 5000; // 5 segundos
                    const startTime = Date.now();
                    
                    alert('üé§ TESTE DE MICROFONE\n\n' +
                          'FALE AGORA por 5 segundos!\n' +
                          'Vamos medir o volume do seu microfone.\n\n' +
                          'Clique OK e comece a falar normalmente.');
                    
                    const checkLevel = () => {
                        analyser.getByteFrequencyData(dataArray);
                        const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
                        
                        if (average > maxLevel) {
                            maxLevel = average;
                        }
                        
                        // Mostrar n√≠vel em tempo real no log
                        if (average > 0) {
                            const bars = '‚ñà'.repeat(Math.floor(average / 5));
                            this.log(`üé§ N√≠vel: ${bars} (${average.toFixed(1)})`);
                        }
                        
                        if (Date.now() - startTime < duration) {
                            requestAnimationFrame(checkLevel);
                        } else {
                            // Finalizar teste
                            stream.getTracks().forEach(track => track.stop());
                            audioContext.close();
                            
                            let resultado = '';
                            if (maxLevel < 5) {
                                resultado = '‚ùå Microfone MUITO BAIXO ou MUDO\n' +
                                          '‚Ä¢ Aumente o volume do microfone no Windows\n' +
                                          '‚Ä¢ Verifique se n√£o est√° mudo\n' +
                                          '‚Ä¢ Fale mais perto do microfone';
                            } else if (maxLevel < 10) {
                                resultado = '‚ö†Ô∏è Microfone BAIXO\n' +
                                          '‚Ä¢ Fale mais alto ou mais perto\n' +
                                          '‚Ä¢ Aumente o volume do microfone';
                            } else if (maxLevel < 30) {
                                resultado = '‚úÖ Microfone OK!\n' +
                                          '‚Ä¢ Volume adequado\n' +
                                          '‚Ä¢ O indicador deve funcionar';
                            } else {
                                resultado = 'üîä Microfone ALTO\n' +
                                          '‚Ä¢ Volume muito alto (pode distorcer)\n' +
                                          '‚Ä¢ Considere reduzir um pouco';
                            }
                            
                            this.log(`üìä Teste finalizado. N√≠vel m√°ximo: ${maxLevel.toFixed(1)}`);
                            alert(`üìä RESULTADO DO TESTE\n\n` +
                                  `N√≠vel m√°ximo detectado: ${maxLevel.toFixed(1)}\n\n` +
                                  resultado);
                        }
                    };
                    
                    checkLevel();
                    
                } catch (error) {
                    this.log(`‚ùå Erro ao testar microfone: ${error.message}`);
                    alert('‚ùå Erro ao acessar microfone!\n\n' + error.message);
                }
            }
            
            async runDiagnostic() {
                const btn = document.getElementById('diagnosticBtn');
                const result = document.getElementById('diagnosticResult');
                
                btn.disabled = true;
                btn.textContent = 'üîÑ Testando...';
                result.innerHTML = '<p>Executando diagn√≥stico...</p>';
                
                try {
                    this.log('üîç Iniciando diagn√≥stico completo...');
                    
                    // 1. Verificar suporte WebRTC
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        throw new Error('WebRTC n√£o suportado neste navegador');
                    }
                    this.log('‚úÖ WebRTC suportado');
                    
                    // 2. Listar dispositivos
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const cameras = devices.filter(d => d.kind === 'videoinput');
                    const mics = devices.filter(d => d.kind === 'audioinput');
                    
                    this.log(`üì± Encontrados: ${cameras.length} c√¢meras, ${mics.length} microfones`);
                    
                    let info = [`üìä <strong>Diagn√≥stico Completo:</strong>`];
                    info.push(`üåê Navegador: ${navigator.userAgent.split(' ').slice(-1)[0]}`);
                    info.push(`üîí Protocolo: ${window.location.protocol}`);
                    info.push(`üìπ C√¢meras: ${cameras.length}`);
                    info.push(`üé§ Microfones: ${mics.length}`);
                    
                    // 3. Testar acesso √† m√≠dia
                    const enableVideo = document.getElementById('enableVideo').checked;
                    const enableAudio = document.getElementById('enableAudio').checked;
                    
                    if (enableVideo || enableAudio) {
                        this.log('üéØ Testando acesso √† m√≠dia...');
                        
                        const testStream = await navigator.mediaDevices.getUserMedia({
                            video: enableVideo ? { width: 640, height: 480 } : false,
                            audio: enableAudio
                        });
                        
                        const videoTracks = testStream.getVideoTracks();
                        const audioTracks = testStream.getAudioTracks();
                        
                        info.push(`‚úÖ <span style="color: green;">V√≠deo: ${videoTracks.length > 0 ? 'FUNCIONANDO' : 'N√£o solicitado'}</span>`);
                        info.push(`‚úÖ <span style="color: green;">√Åudio: ${audioTracks.length > 0 ? 'FUNCIONANDO' : 'N√£o solicitado'}</span>`);
                        
                        // Mostrar detalhes dos tracks
                        videoTracks.forEach((track, i) => {
                            const settings = track.getSettings();
                            info.push(`üìπ C√¢mera ${i+1}: ${settings.width}x${settings.height}`);
                        });
                        
                        audioTracks.forEach((track, i) => {
                            const settings = track.getSettings();
                            info.push(`üé§ Microfone ${i+1}: ${settings.sampleRate || 'desconhecido'}Hz`);
                        });
                        
                        // Parar teste
                        testStream.getTracks().forEach(track => track.stop());
                        
                        info.push(`<br><span style="color: green; font-weight: bold;">üéâ SUCESSO! Seus dispositivos funcionam perfeitamente.</span>`);
                        info.push(`‚úÖ Pode usar "Conectar na Sala" com seguran√ßa.`);
                        
                        this.log('‚úÖ Diagn√≥stico: SUCESSO!');
                        
                    } else {
                        info.push(`‚ö†Ô∏è <span style="color: orange;">Nenhuma m√≠dia selecionada para teste</span>`);
                        info.push(`üí° Use "Entrar S√≥ para Ver/Ouvir" se quiser conectar sem c√¢mera/mic`);
                    }
                    
                    result.innerHTML = '<div class="success">' + info.join('<br>') + '</div>';
                    
                } catch (error) {
                    this.log(`‚ùå Erro no diagn√≥stico: ${error.name} - ${error.message}`);
                    
                    let errorInfo = [`‚ùå <strong>Erro Encontrado:</strong>`];
                    errorInfo.push(`üö´ Tipo: ${error.name}`);
                    errorInfo.push(`üìù Mensagem: ${error.message}`);
                    errorInfo.push(`<br><strong>üîß Solu√ß√µes Recomendadas:</strong>`);
                    
                    if (error.name === 'NotFoundError') {
                        errorInfo.push(`1. üì± Conecte uma c√¢mera/microfone USB`);
                        errorInfo.push(`2. üîÑ Verifique se outros apps n√£o est√£o usando`);
                        errorInfo.push(`3. üíª Reinstale drivers de √°udio/v√≠deo`);
                    } else if (error.name === 'NotAllowedError') {
                        errorInfo.push(`1. üîí Clique no √≠cone de CADEADO na barra de endere√ßo`);
                        errorInfo.push(`2. ‚úÖ Selecione "Permitir" para c√¢mera e microfone`);
                        errorInfo.push(`3. üîÑ Recarregue a p√°gina (F5)`);
                    } else if (error.name === 'NotReadableError') {
                        errorInfo.push(`1. ‚ùå Feche: Zoom, Teams, Discord, OBS, Skype`);
                        errorInfo.push(`2. üåê Feche outras abas com v√≠deo`);
                        errorInfo.push(`3. üîÑ Reinicie o navegador`);
                    }
                    
                    errorInfo.push(`<br><span style="color: blue; font-weight: bold;">üí° ALTERNATIVA: Use "Entrar S√≥ para Ver/Ouvir"</span>`);
                    
                    result.innerHTML = '<div class="error">' + errorInfo.join('<br>') + '</div>';
                } finally {
                    btn.disabled = false;
                    btn.textContent = 'üîç Testar C√¢mera/Microfone';
                }
            }
            
            async listDevices() {
                try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    
                    this.log('üì± Listando todos os dispositivos:');
                    devices.forEach((device, index) => {
                        const label = device.label || `Dispositivo ${index + 1}`;
                        const id = device.deviceId.substring(0, 8) + '...';
                        this.log(`  ${index + 1}. [${device.kind}] ${label} (${id})`);
                    });
                    
                    const cameras = devices.filter(d => d.kind === 'videoinput');
                    const mics = devices.filter(d => d.kind === 'audioinput');
                    
                    alert(`üì± Dispositivos encontrados:\n\nüìπ C√¢meras: ${cameras.length}\nüé§ Microfones: ${mics.length}\n\n(Veja detalhes no log)`);
                    
                } catch (error) {
                    this.log(`‚ùå Erro ao listar dispositivos: ${error.message}`);
                    alert('Erro ao listar dispositivos: ' + error.message);
                }
            }
            
            async connect(useMedia = true) {
                const name = document.getElementById('nameInput').value.trim();
                const room = document.getElementById('roomInput').value.trim();
                
                if (!name || !room) {
                    alert('‚ùå Preencha seu nome e ID da sala!');
                    return;
                }
                
                this.userName = name;
                this.userId = 'user_' + Date.now();
                
                this.log(`üöÄ Conectando como "${name}" na sala "${room}"...`);
                this.updateStatus('üîÑ Conectando...', false);
                
                try {
                    // 1. Obter m√≠dia apenas se solicitado
                    if (useMedia) {
                        const enableVideo = document.getElementById('enableVideo').checked;
                        const enableAudio = document.getElementById('enableAudio').checked;
                        
                        if (enableVideo || enableAudio) {
                            this.log('üìπ Solicitando acesso √† m√≠dia...');
                            
                            try {
                                this.localStream = await navigator.mediaDevices.getUserMedia({
                                    video: enableVideo ? { 
                                        width: { ideal: 640 },
                                        height: { ideal: 480 }
                                    } : false,
                                    audio: enableAudio
                                });
                                
                                this.log('‚úÖ M√≠dia obtida com sucesso!');
                                this.createVideoElement('local', `${name} (Voc√™)`, this.localStream, true);
                                // Configurar detec√ß√£o de √°udio para o stream local
                                this.setupAudioDetection(this.localStream, 'local');
                                
                            } catch (mediaError) {
                                this.log(`‚ùå Erro de m√≠dia: ${mediaError.message}`);
                                
                                const continueAnyway = confirm(
                                    `‚ùå Erro ao acessar c√¢mera/microfone:\n${mediaError.message}\n\n` +
                                    `üí° Deseja continuar SEM m√≠dia?\n(Voc√™ poder√° ver/ouvir outros usu√°rios)`
                                );
                                
                                if (!continueAnyway) {
                                    this.updateStatus('‚ùå Conex√£o cancelada', false);
                                    return;
                                }
                                
                                this.log('‚ö†Ô∏è Continuando sem m√≠dia...');
                            }
                        } else {
                            this.log('‚ö†Ô∏è Nenhuma m√≠dia selecionada - entrando como ouvinte');
                        }
                    } else {
                        this.log('üëÅÔ∏è Modo apenas visualiza√ß√£o - sem c√¢mera/microfone');
                    }
                    
                    // 2. Conectar WebSocket - Detecta ambiente automaticamente
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const host = window.location.host; // Usa o host atual (localhost:8084 ou seu-app.onrender.com)
                    const wsUrl = `${protocol}//${host}/video-signaling?user_id=${this.userId}&user_name=${encodeURIComponent(name)}&room=${encodeURIComponent(room)}`;
                    
                    this.log(`üåê Conectando ao servidor: ${host}...`);
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => {
                        this.log('‚úÖ WebSocket conectado!');
                        this.isConnected = true;
                        this.updateUI();
                        this.updateStatus(`üü¢ Conectado na sala: ${room}`, true);
                    };
                    
                    this.ws.onmessage = (event) => {
                        const message = JSON.parse(event.data);
                        this.log(`üì® [${message.type}] de ${message.from || 'servidor'}`);
                        this.handleMessage(message);
                    };
                    
                    this.ws.onclose = () => {
                        this.log('üî¥ WebSocket desconectado');
                        this.isConnected = false;
                        this.updateUI();
                        this.updateStatus('üî¥ Desconectado', false);
                    };
                    
                    this.ws.onerror = () => {
                        this.log('‚ùå Erro de conex√£o WebSocket - Verifique se o servidor est√° rodando na porta 8084');
                        this.updateStatus('‚ùå Erro de conex√£o', false);
                        alert('‚ùå N√£o foi poss√≠vel conectar ao servidor.\n\nVerifique:\n1. O servidor Go est√° rodando?\n2. Est√° na porta 8084?\n3. Execute: go run main.go');
                    };
                    
                } catch (error) {
                    this.log(`‚ùå Erro geral: ${error.message}`);
                    this.updateStatus('‚ùå Erro na conex√£o', false);
                    alert('Erro: ' + error.message);
                }
            }
            
            async handleMessage(message) {
                switch (message.type) {
                    case 'user-list':
                        this.log(`üë• ${message.user_list ? message.user_list.length : 0} usu√°rios na sala`);
                        if (message.user_list && message.user_list.length > 0) {
                            for (const user of message.user_list) {
                                await this.createPeerConnection(user.id, user.name, true);
                                this.createVideoElement(user.id, user.name);
                            }
                        }
                        break;
                        
                    case 'user-joined':
                        this.log(`üëã ${message.user_info.name} entrou`);
                        this.createVideoElement(message.user_info.id, message.user_info.name);
                        // IMPORTANTE: Criar conex√£o P2P quando algu√©m entrar
                        await this.createPeerConnection(message.from || message.user_info.id, message.user_info.name, false);
                        break;
                        
                    case 'user-left':
                        this.log(`üëã ${message.from} saiu`);
                        this.removeVideoElement(message.from);
                        if (this.peerConnections.has(message.from)) {
                            this.peerConnections.get(message.from).close();
                            this.peerConnections.delete(message.from);
                        }
                        break;
                        
                    case 'offer':
                        await this.handleOffer(message);
                        break;
                        
                    case 'answer':
                        await this.handleAnswer(message);
                        break;
                        
                    case 'ice-candidate':
                        await this.handleIceCandidate(message);
                        break;
                        
                    case 'error':
                        this.log(`‚ùå Erro do servidor: ${message.message}`);
                        break;
                }
            }
            
            async createPeerConnection(userId, userName, createOffer = false) {
                this.log(`ü§ù Iniciando conex√£o P2P com ${userName} (${userId})...`);
                
                try {
                    const pc = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    });
                    
                    // Adicionar stream local se houver
                    if (this.localStream) {
                        this.localStream.getTracks().forEach(track => {
                            pc.addTrack(track, this.localStream);
                            this.log(`üì§ Adicionando ${track.kind} para enviar para ${userName}`);
                        });
                    } else {
                        this.log(`‚ö†Ô∏è Sem stream local para enviar para ${userName}`);
                    }
                    
                    // Eventos
                    pc.onicecandidate = (event) => {
                        if (event.candidate) {
                            this.log(`üßä Enviando ICE candidate para ${userName}`);
                            this.sendMessage({
                                type: 'ice-candidate',
                                to: userId,
                                ice: event.candidate.toJSON()
                            });
                        }
                    };
                    
                    pc.ontrack = (event) => {
                        this.log(`üì• Stream recebido de ${userName} - ${event.track.kind}`);
                        this.updateVideoElement(userId, event.streams[0]);
                    };
                    
                    pc.onconnectionstatechange = () => {
                        this.log(`üîó Estado da conex√£o com ${userName}: ${pc.connectionState}`);
                        if (pc.connectionState === 'connected') {
                            this.log(`‚úÖ P2P CONECTADO com ${userName}!`);
                        } else if (pc.connectionState === 'failed') {
                            this.log(`‚ùå P2P FALHOU com ${userName}`);
                        }
                    };
                    
                    this.peerConnections.set(userId, pc);
                    
                    if (createOffer) {
                        this.log(`üìû Criando oferta para ${userName}...`);
                        const offer = await pc.createOffer();
                        await pc.setLocalDescription(offer);
                        
                        const offerMsg = {
                            type: 'offer',
                            to: userId,
                            offer: offer
                        };
                        
                        this.log(`üì§ Enviando oferta para ${userName}`);
                        this.sendMessage(offerMsg);
                    }
                    
                } catch (error) {
                    this.log(`‚ùå Erro ao criar conex√£o P2P com ${userName}: ${error.message}`);
                }
            }
            
            async handleOffer(message) {
                this.log(`üìû Recebendo oferta de ${message.from}`);
                
                try {
                    // Verificar se j√° existe conex√£o
                    if (this.peerConnections.has(message.from)) {
                        this.log(`‚ö†Ô∏è Conex√£o j√° existe com ${message.from}, recriando...`);
                        this.peerConnections.get(message.from).close();
                    }
                    
                    const pc = new RTCPeerConnection({
                        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                    });
                    
                    // Eventos
                    pc.onicecandidate = (event) => {
                        if (event.candidate) {
                            this.log(`üßä Enviando ICE candidate de volta para ${message.from}`);
                            this.sendMessage({
                                type: 'ice-candidate',
                                to: message.from,
                                ice: event.candidate.toJSON()
                            });
                        }
                    };
                    
                    pc.ontrack = (event) => {
                        this.log(`üì• Stream recebido via oferta de ${message.from} - ${event.track.kind}`);
                        this.updateVideoElement(message.from, event.streams[0]);
                    };
                    
                    pc.onconnectionstatechange = () => {
                        this.log(`üîó Estado da conex√£o (offer) com ${message.from}: ${pc.connectionState}`);
                    };
                    
                    // Adicionar stream local se houver
                    if (this.localStream) {
                        this.localStream.getTracks().forEach(track => {
                            pc.addTrack(track, this.localStream);
                            this.log(`üì§ Adicionando ${track.kind} na resposta para ${message.from}`);
                        });
                    }
                    
                    this.peerConnections.set(message.from, pc);
                    
                    await pc.setRemoteDescription(message.offer);
                    this.log(`‚úÖ Oferta processada de ${message.from}`);
                    
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    
                    const answerMsg = {
                        type: 'answer',
                        to: message.from,
                        answer: answer
                    };
                    
                    this.log(`üì§ Enviando resposta para ${message.from}`);
                    this.sendMessage(answerMsg);
                    
                } catch (error) {
                    this.log(`‚ùå Erro ao processar oferta: ${error.message}`);
                }
            }
            
            async handleAnswer(message) {
                this.log(`üìû Recebendo resposta de ${message.from}`);
                const pc = this.peerConnections.get(message.from);
                if (pc) {
                    try {
                        await pc.setRemoteDescription(message.answer);
                        this.log(`‚úÖ Resposta processada de ${message.from}`);
                    } catch (error) {
                        this.log(`‚ùå Erro ao processar resposta: ${error.message}`);
                    }
                } else {
                    this.log(`‚ö†Ô∏è Nenhuma conex√£o encontrada para ${message.from}`);
                }
            }
            
            async handleIceCandidate(message) {
                this.log(`üßä Recebendo ICE candidate de ${message.from}`);
                const pc = this.peerConnections.get(message.from);
                if (pc && message.ice) {
                    try {
                        await pc.addIceCandidate(message.ice);
                        this.log(`‚úÖ ICE candidate adicionado de ${message.from}`);
                    } catch (error) {
                        this.log(`‚ùå Erro ao adicionar ICE: ${error.message}`);
                    }
                }
            }
            
            createVideoElement(userId, userName, stream = null, isMuted = false) {
                const container = document.getElementById('videosContainer');
                
                // N√£o duplicar
                if (document.getElementById(`video-${userId}`)) return;
                
                const videoBox = document.createElement('div');
                videoBox.className = `video-box ${userId === 'local' ? 'local' : 'remote'}`;
                videoBox.id = `video-${userId}`;
                
                if (stream) {
                    const video = document.createElement('video');
                    video.autoplay = true;
                    video.playsInline = true;
                    video.muted = isMuted;
                    video.srcObject = stream;
                    videoBox.appendChild(video);
                    
                    // Adicionar detector de √°udio
                    if (!isMuted) {
                        this.setupAudioDetection(stream, userId);
                    }
                } else {
                    const noVideo = document.createElement('div');
                    noVideo.className = 'no-video';
                    noVideo.innerHTML = `
                        <div class="avatar">${userName.charAt(0).toUpperCase()}</div>
                        <div>Sem v√≠deo</div>
                    `;
                    videoBox.appendChild(noVideo);
                    
                    // Adicionar detector de √°udio mesmo sem v√≠deo se houver stream
                    if (stream && stream.getAudioTracks().length > 0) {
                        this.setupAudioDetection(stream, userId);
                    }
                }
                
                const label = document.createElement('div');
                label.className = 'video-label';
                label.innerHTML = `
                    ${userName}
                    <span class="audio-indicator" id="audio-${userId}">üîá</span>
                `;
                videoBox.appendChild(label);
                
                container.appendChild(videoBox);
                this.log(`üì∫ V√≠deo criado: ${userName}`);
            }
            
            setupAudioDetection(stream, userId) {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const analyser = audioContext.createAnalyser();
                    const microphone = audioContext.createMediaStreamSource(stream);
                    const dataArray = new Uint8Array(analyser.frequencyBinCount);
                    
                    analyser.smoothingTimeConstant = 0.8;
                    analyser.fftSize = 256;
                    microphone.connect(analyser);
                    
                    const checkAudio = () => {
                        analyser.getByteFrequencyData(dataArray);
                        const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
                        
                        const indicator = document.getElementById(`audio-${userId}`);
                        if (indicator) {
                            // Threshold reduzido de 10 para 5 - mais sens√≠vel
                            if (average > 5) { 
                                indicator.classList.add('active');
                                indicator.textContent = 'üîä';
                                
                                // Log para debug quando detectar som
                                if (userId === 'local' && !this.lastSoundLog) {
                                    this.log(`üé§ Som detectado! N√≠vel: ${average.toFixed(1)}`);
                                    this.lastSoundLog = true;
                                    setTimeout(() => this.lastSoundLog = false, 1000);
                                }
                            } else {
                                indicator.classList.remove('active');
                                indicator.textContent = 'üîá';
                            }
                        }
                        
                        requestAnimationFrame(checkAudio);
                    };
                    
                    checkAudio();
                    this.log(`üéôÔ∏è Detector de √°udio ativado para ${userId} - Sensibilidade alta`);
                } catch (error) {
                    this.log(`‚ö†Ô∏è N√£o foi poss√≠vel ativar detector de √°udio: ${error.message}`);
                }
            }
            
            updateVideoElement(userId, stream) {
                const videoBox = document.getElementById(`video-${userId}`);
                if (!videoBox) return;
                
                // Remover placeholder se existir
                const noVideo = videoBox.querySelector('.no-video');
                if (noVideo) noVideo.remove();
                
                // Adicionar ou atualizar v√≠deo
                let video = videoBox.querySelector('video');
                if (!video) {
                    video = document.createElement('video');
                    video.autoplay = true;
                    video.playsInline = true;
                    videoBox.insertBefore(video, videoBox.lastElementChild);
                }
                
                video.srcObject = stream;
                
                // Configurar detec√ß√£o de √°udio para streams remotos
                this.setupAudioDetection(stream, userId);
                
                this.log(`üîÑ V√≠deo atualizado: ${userId}`);
            }
            
            testMyAudio() {
                this.log('üîä Iniciando teste de √°udio...');
                
                // Criar um som de teste
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Tom de teste
                oscillator.frequency.value = 440; // Nota L√° (A4)
                gainNode.gain.value = 0.3;
                oscillator.type = 'sine';
                
                // Tocar por 1 segundo
                oscillator.start();
                
                alert('üîä TESTE DE √ÅUDIO\n\n' +
                      '1. Voc√™ deve ouvir um "beep" agora\n' +
                      '2. Se n√£o ouvir, verifique:\n' +
                      '   ‚Ä¢ Volume do computador\n' +
                      '   ‚Ä¢ Fones/caixas de som\n\n' +
                      '3. Para testar o MICROFONE:\n' +
                      '   ‚Ä¢ Fale ap√≥s conectar\n' +
                      '   ‚Ä¢ Veja o indicador üîä piscar\n' +
                      '   ‚Ä¢ Outros usu√°rios ver√£o quando voc√™ falar');
                
                setTimeout(() => {
                    oscillator.stop();
                    this.log('‚úÖ Teste de √°udio finalizado');
                }, 1000);
            }
            
            removeVideoElement(userId) {
                const videoBox = document.getElementById(`video-${userId}`);
                if (videoBox) {
                    videoBox.remove();
                    this.log(`üóëÔ∏è V√≠deo removido: ${userId}`);
                }
            }
            
            toggleCamera() {
                if (!this.localStream) {
                    this.log('‚ùå N√£o h√° stream local para controlar');
                    return;
                }
                
                const videoTrack = this.localStream.getVideoTracks()[0];
                if (videoTrack) {
                    videoTrack.enabled = !videoTrack.enabled;
                    this.log(`üìπ C√¢mera: ${videoTrack.enabled ? 'LIGADA' : 'DESLIGADA'}`);
                } else {
                    this.log('‚ùå Nenhum track de v√≠deo encontrado');
                }
            }
            
            toggleMic() {
                if (!this.localStream) {
                    this.log('‚ùå N√£o h√° stream local para controlar');
                    return;
                }
                
                const audioTrack = this.localStream.getAudioTracks()[0];
                if (audioTrack) {
                    audioTrack.enabled = !audioTrack.enabled;
                    this.log(`üé§ Microfone: ${audioTrack.enabled ? 'LIGADO' : 'DESLIGADO'}`);
                } else {
                    this.log('‚ùå Nenhum track de √°udio encontrado');
                }
            }
            
            disconnect() {
                this.log('üö™ Desconectando...');
                
                if (this.ws) this.ws.close();
                
                this.peerConnections.forEach((pc, userId) => {
                    pc.close();
                    this.log(`üîå Conex√£o fechada com ${userId}`);
                });
                this.peerConnections.clear();
                
                if (this.localStream) {
                    this.localStream.getTracks().forEach(track => {
                        track.stop();
                        this.log(`‚èπÔ∏è ${track.kind} parado`);
                    });
                    this.localStream = null;
                }
                
                // Limpar v√≠deos
                document.getElementById('videosContainer').innerHTML = '';
                
                this.isConnected = false;
                this.updateUI();
                this.updateStatus('üî¥ Desconectado', false);
            }
            
            sendMessage(message) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(message));
                } else {
                    this.log('‚ùå WebSocket n√£o conectado');
                }
            }
            
            updateUI() {
                document.getElementById('connectBtn').disabled = this.isConnected;
                document.getElementById('connectNoMediaBtn').disabled = this.isConnected;
                document.getElementById('disconnectBtn').disabled = !this.isConnected;
                document.getElementById('toggleCameraBtn').disabled = !this.isConnected || !this.localStream;
                document.getElementById('toggleMicBtn').disabled = !this.isConnected || !this.localStream;
                document.getElementById('reconnectPeersBtn').disabled = !this.isConnected;
            }
            
            updateStatus(message, isConnected) {
                const status = document.getElementById('statusBar');
                status.textContent = message;
                status.className = `status-bar ${isConnected ? 'status-connected' : ''}`;
            }
            
            log(message) {
                const logs = document.getElementById('logsContainer');
                const time = new Date().toLocaleTimeString();
                logs.innerHTML += `<span style="color: #666;">[${time}]</span> ${message}<br>`;
                logs.scrollTop = logs.scrollHeight;
                console.log(`[VideoConf] ${message}`);
            }
        }
        
        // Inicializar
        window.onload = () => {
            new SimpleVideoConf();
        };
    </script>
</body>
</html>
